<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Manual · NiLang.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NiLang.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../why/">What and Why</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">My first NiLang program</a></li><li><a class="tocitem" href="../examples/port_zygote/">How to port NiLang to Zygote</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fib/">Computing Fibonacci Numbers</a></li><li><a class="tocitem" href="../examples/besselj/">Bessel function</a></li><li><a class="tocitem" href="../examples/sparse/">Sparse matrices</a></li><li><a class="tocitem" href="../examples/unitary/">Unitary matrix operations without allocation</a></li><li><a class="tocitem" href="../examples/qr/">A simple QR decomposition</a></li><li><a class="tocitem" href="../examples/nice/">NICE network</a></li><li><a class="tocitem" href="../examples/realnvp/">RealNVP network</a></li></ul></li><li><span class="tocitem">API &amp; Manual</span><ul><li><a class="tocitem" href="../instructions/">Instruction Reference</a></li><li><a class="tocitem" href="../extend/">How to extend</a></li><li><a class="tocitem" href="../examples/sharedwrite/">The shared write problem on GPU</a></li><li class="is-active"><a class="tocitem" href>API Manual</a><ul class="internal"><li><a class="tocitem" href="#Compiling-Tools-(Reexported-from-NiLangCore)-1"><span>Compiling Tools (Reexported from NiLangCore)</span></a></li><li><a class="tocitem" href="#Instructions-1"><span>Instructions</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation-1"><span>Automatic Differentiation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API &amp; Manual</a></li><li class="is-active"><a href>API Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Manual-1"><a class="docs-heading-anchor" href="#API-Manual-1">API Manual</a><a class="docs-heading-anchor-permalink" href="#API-Manual-1" title="Permalink"></a></h1><h2 id="Compiling-Tools-(Reexported-from-NiLangCore)-1"><a class="docs-heading-anchor" href="#Compiling-Tools-(Reexported-from-NiLangCore)-1">Compiling Tools (Reexported from NiLangCore)</a><a class="docs-heading-anchor-permalink" href="#Compiling-Tools-(Reexported-from-NiLangCore)-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@assign" href="#NiLangCore.@assign"><code>NiLangCore.@assign</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@assign a b [invcheck]</code></pre><p>Perform the assign <code>a = b</code> in a reversible program. Turn off invertibility check if the <code>invcheck</code> is false.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@assignback" href="#NiLangCore.@assignback"><code>NiLangCore.@assignback</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@assignback f(args...) [invcheck]</code></pre><p>Assign input variables with output values: <code>args... = f(args...)</code>, turn off invertibility error check if the second argument is false.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_julia-Tuple{Any}" href="#NiLangCore.@code_julia-Tuple{Any}"><code>NiLangCore.@code_julia</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@code_julia ex</code></pre><p>Get the interpreted expression of <code>ex</code>.</p><pre><code class="language-julia-repl">julia&gt; using MacroTools

julia&gt; prettify(@code_julia x += exp(3.0))
:(@assignback (PlusEq(exp))(x, 3.0))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_preprocess-Tuple{Any}" href="#NiLangCore.@code_preprocess-Tuple{Any}"><code>NiLangCore.@code_preprocess</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@code_preprocess ex</code></pre><p>Preprocess <code>ex</code> and return the symmetric reversible IR.</p><pre><code class="language-julia-repl">julia&gt; using MacroTools

julia&gt; prettify(@code_preprocess if (x &lt; 3, ~) x += exp(3.0) end)
:(if (x &lt; 3, x &lt; 3)
      x += exp(3.0)
  else
  end)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_reverse-Tuple{Any}" href="#NiLangCore.@code_reverse-Tuple{Any}"><code>NiLangCore.@code_reverse</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@code_reverse ex</code></pre><p>Get the reversed expression of <code>ex</code>.</p><pre><code class="language-julia-repl">julia&gt; @code_reverse x += exp(3.0)
:(x -= exp(3.0))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@dual-Tuple{Any,Any}" href="#NiLangCore.@dual-Tuple{Any,Any}"><code>NiLangCore.@dual</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@dual f invf</code></pre><p>Define <code>f</code> and <code>invf</code> as a pair of dual instructions, i.e. reverse to each other.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@fieldview-Tuple{Any}" href="#NiLangCore.@fieldview-Tuple{Any}"><code>NiLangCore.@fieldview</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@fieldview fname(x::TYPE) = x.fieldname</code></pre><p>Create a function fieldview that can be accessed by a reversible program</p><pre><code class="language-julia-repl">julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64,Float64}(2.0, 0.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@i-Tuple{Any}" href="#NiLangCore.@i-Tuple{Any}"><code>NiLangCore.@i</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@i function fname(args..., kwargs...) ... end
@i struct sname ... end</code></pre><p>Define a reversible function/type.</p><pre><code class="language-julia-repl">julia&gt; @i function test(out!, x)
           out! += identity(x)
       end

julia&gt; test(0.2, 0.8)
(1.0, 0.8)

julia&gt; @i struct CVar{T}
           g::T
           x::T
           function CVar{T}(x::T, g::T) where T
               new{T}(x, g)
           end
           function CVar(x::T, g::T) where T
               new{T}(x, g)
           end
           # warning: infered type `T` should be used in `← new` statement only.
           @i function CVar(xx::T) where T
               gg ← zero(xx)
               gg += identity(1)
               xx ← new{T}(gg, xx)
           end
       end

julia&gt; CVar(0.2)
CVar{Float64}(1.0, 0.2)

julia&gt; (~CVar)(CVar(0.2))
0.2</code></pre><p>See <code>test/compiler.jl</code> and <code>test/invtype.jl</code> for more examples.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@icast-Tuple{Any,Any}" href="#NiLangCore.@icast-Tuple{Any,Any}"><code>NiLangCore.@icast</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@icast TDEF1 =&gt; TDEF2 begin ... end</code></pre><p>Define type cast between <code>TDEF1</code> and <code>TDEF2</code>. Type <code>TDEF1</code> or <code>TDEF2</code> can be <code>T(args...)</code> or <code>x::T</code> like.</p><pre><code class="language-julia-repl">julia&gt; struct PVar{T}
           g::T
           x::T
       end

julia&gt; struct SVar{T}
           x::T
           g::T
       end

julia&gt; @icast PVar(g, x) =&gt; SVar(x, k) begin
          g → zero(x)
          k ← zero(x)
          k += identity(x)
       end

julia&gt; x = PVar(0.0, 0.5)
PVar{Float64}(0.0, 0.5)

julia&gt; @instr (PVar=&gt;SVar)(x)
SVar{Float64}(0.5, 0.5)

julia&gt; @instr (SVar=&gt;PVar)(x)
PVar{Float64}(0.0, 0.5)

julia&gt; @icast x::Base.Float64 =&gt; SVar(x, gg) begin
           gg ← zero(x)
           gg += identity(x)
       end

julia&gt; x = 0.5
0.5

julia&gt; @instr (Float64=&gt;SVar)(x)
SVar{Float64}(0.5, 0.5)

julia&gt; @instr (SVar=&gt;Float64)(x)
0.5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@instr-Tuple{Any}" href="#NiLangCore.@instr-Tuple{Any}"><code>NiLangCore.@instr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@instr ex</code></pre><p>Execute a reversible instruction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@invcheck-Tuple{Any}" href="#NiLangCore.@invcheck-Tuple{Any}"><code>NiLangCore.@invcheck</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invcheck ex
@invcheck x val</code></pre><p>Pass the check it if <code>ex</code> is true or <code>x ≈ val</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@pure_wrapper-Tuple{Any}" href="#NiLangCore.@pure_wrapper-Tuple{Any}"><code>NiLangCore.@pure_wrapper</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pure_wrapper TYPE</code></pre><p>Create a reversible wrapper type <code>TYPE{T} &lt;: IWrapper{T}</code> that plays a role of simple wrapper.</p><pre><code class="language-julia-repl">julia&gt; @pure_wrapper A

julia&gt; A(0.5)
A(0.5)

julia&gt; (~A)(A(0.5))
0.5

julia&gt; -A(0.5)
A(-0.5)

julia&gt; A(0.5) &lt; A(0.6)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@selfdual-Tuple{Any}" href="#NiLangCore.@selfdual-Tuple{Any}"><code>NiLangCore.@selfdual</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@selfdual f</code></pre><p>Define <code>f</code> as a self-dual instructions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.almost_same-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Number" href="#NiLangCore.almost_same-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Number"><code>NiLangCore.almost_same</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">almost_same(a, b; atol=GLOBAL_ATOL[], kwargs...) -&gt; Bool</code></pre><p>Return true if <code>a</code> and <code>b</code> are almost same w.r.t. <code>atol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.check_inv-Tuple{Any,Any}" href="#NiLangCore.check_inv-Tuple{Any,Any}"><code>NiLangCore.check_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_inv(f, args; atol::Real=1e-8, verbose::Bool=false, kwargs...)</code></pre><p>Return true if <code>f(args..., kwargs...)</code> is reversible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.chfield" href="#NiLangCore.chfield"><code>NiLangCore.chfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">chfield(x, field, val)</code></pre><p>Change a <code>field</code> of an object <code>x</code>.</p><p>The <code>field</code> can be a <code>Val</code> type</p><pre><code class="language-julia-repl">julia&gt; chfield(1+2im, Val(:im), 5)
1 + 5im</code></pre><p>or a function</p><pre><code class="language-julia-repl">julia&gt; using NiLangCore

julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64,Float64}(2.0, 0.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isprimitive-Tuple{Any}" href="#NiLangCore.isprimitive-Tuple{Any}"><code>NiLangCore.isprimitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isprimitive(f)</code></pre><p>Return <code>true</code> if <code>f</code> is an <code>instruction</code> that can not be decomposed anymore.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isreflexive-Tuple{Any}" href="#NiLangCore.isreflexive-Tuple{Any}"><code>NiLangCore.isreflexive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isreflexive(f)</code></pre><p>Return <code>true</code> if a function is self-inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isreversible-Union{Tuple{ARGT}, Tuple{Any,Type{ARGT}}} where ARGT" href="#NiLangCore.isreversible-Union{Tuple{ARGT}, Tuple{Any,Type{ARGT}}} where ARGT"><code>NiLangCore.isreversible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isreversible(f, ARGT)</code></pre><p>Return <code>true</code> if a function is reversible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.nargs" href="#NiLangCore.nargs"><code>NiLangCore.nargs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nargs(instr)</code></pre><p>Number of arguments as the input of <code>instr</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.nilang_ir-Tuple{Any}" href="#NiLangCore.nilang_ir-Tuple{Any}"><code>NiLangCore.nilang_ir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nilang_ir(ex; reversed::Bool=false)</code></pre><p>Get the NiLang reversible IR from the function expression <code>ex</code>, return the reversed function if <code>reversed</code> is <code>true</code>.</p><p>This IR is not directly executable on Julia, please use <code>macroexpand(Main, :(@i function .... end))</code> to get the julia expression of a reversible function.</p><pre><code class="language-julia-repl">julia&gt; ex = :(@inline function f(x!::T, y) where T
               anc ← zero(T)
               @routine anc += identity(x!)
               x! += y * anc
               ~@routine
           end);

julia&gt; nilang_ir(ex) |&gt; MacroTools.prettify
:(@inline function f(x!::T, y) where T
          anc ← zero(T)
          anc += identity(x!)
          x! += y * anc
          anc -= identity(x!)
          anc → zero(T)
      end)

julia&gt; nilang_ir(ex; reversed=true) |&gt; MacroTools.prettify
:(@inline function (~f)(x!::T, y) where T
          anc ← zero(T)
          anc += identity(x!)
          x! -= y * anc
          anc -= identity(x!)
          anc → zero(T)
      end)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.nouts" href="#NiLangCore.nouts"><code>NiLangCore.nouts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nouts(instr)</code></pre><p>Number of output arguments in the input list of <code>instr</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.tget-Tuple{Tuple,Vararg{Any,N} where N}" href="#NiLangCore.tget-Tuple{Tuple,Vararg{Any,N} where N}"><code>NiLangCore.tget</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tget(x::Tuple, i)</code></pre><p>Get the i-th entry of a tuple.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.unwrap-Tuple{IWrapper}" href="#NiLangCore.unwrap-Tuple{IWrapper}"><code>NiLangCore.unwrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unwrap(x)</code></pre><p>Unwrap a wrapper instance (recursively) to get the original value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.value-Tuple{Any}" href="#NiLangCore.value-Tuple{Any}"><code>NiLangCore.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value(x)</code></pre><p>Get the <code>value</code> from a wrapper instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.DivEq" href="#NiLangCore.DivEq"><code>NiLangCore.DivEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DivEq{FT} &lt;: Function
DivEq(f)</code></pre><p>Called when executing <code>out /= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.IWrapper" href="#NiLangCore.IWrapper"><code>NiLangCore.IWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IWrapper{T} &lt;: Real</code></pre><p>IWrapper{T} is a wrapper of for data of type T. It will forward <code>&gt;, &lt;, &gt;=, &lt;=, ≈</code> operations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.Inv" href="#NiLangCore.Inv"><code>NiLangCore.Inv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Inv{FT} &lt;: Function
Inv(f)</code></pre><p>The inverse of a function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.InvertibilityError" href="#NiLangCore.InvertibilityError"><code>NiLangCore.InvertibilityError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvertibilityError &lt;: Exception
InvertibilityError(ex)</code></pre><p>The error thrown when a irreversible statement appears in a reversible context.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.MinusEq" href="#NiLangCore.MinusEq"><code>NiLangCore.MinusEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MinusEq{FT} &lt;: Function
MinusEq(f)
⊖(f)</code></pre><p>Called when executing <code>out -= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.MulEq" href="#NiLangCore.MulEq"><code>NiLangCore.MulEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MulEq{FT} &lt;: Function
MulEq(f)</code></pre><p>Called when executing <code>out *= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.Partial" href="#NiLangCore.Partial"><code>NiLangCore.Partial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Partial{FIELD, T, T2} &lt;: IWrapper{T2}</p><p>Take a field <code>FIELD</code> without dropping information. This operation can be undone by calling <code>~Partial{FIELD}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.PlusEq" href="#NiLangCore.PlusEq"><code>NiLangCore.PlusEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlusEq{FT} &lt;: Function
PlusEq(f)
⊕(f)</code></pre><p>Called when executing <code>out += f(args...)</code> instruction. The following two statements are same</p><pre><code class="language-julia-repl">julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; x, y, z = PlusEq(*)(x, y, z)
(6.0, 2.0, 3.0)

julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; @instr x += y*z
3.0

julia&gt; x, y, z
(6.0, 2.0, 3.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.XorEq" href="#NiLangCore.XorEq"><code>NiLangCore.XorEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">XorEq{FT} &lt;: Function
XorEq(f)
⊙(f)</code></pre><p>Called when executing <code>out ⊻= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@anc-Tuple{Any}" href="#NiLangCore.@anc-Tuple{Any}"><code>NiLangCore.@anc</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@anc x = expr</code></pre><p>Create an ancilla <code>x</code> with initial value <code>expr</code>,</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@deanc-Tuple{Any}" href="#NiLangCore.@deanc-Tuple{Any}"><code>NiLangCore.@deanc</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@deanc x = expr</code></pre><p>Deallocate ancilla <code>x</code> if <code>x == expr</code>, else throw an <code>InvertibilityError</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.assign_vars-Tuple{Any,Any}" href="#NiLangCore.assign_vars-Tuple{Any,Any}"><code>NiLangCore.assign_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assign_vars(args, symres; invcheck)</code></pre><p>Get the expression of assigning <code>symres</code> to <code>args</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.bcast_assign_vars-Tuple{Any,Any}" href="#NiLangCore.bcast_assign_vars-Tuple{Any,Any}"><code>NiLangCore.bcast_assign_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The broadcast version of <code>assign_vars</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.compile_ex-Tuple{Any,Any}" href="#NiLangCore.compile_ex-Tuple{Any,Any}"><code>NiLangCore.compile_ex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>translate to normal julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.dual_ex-Tuple{Any}" href="#NiLangCore.dual_ex-Tuple{Any}"><code>NiLangCore.dual_ex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dual_ex(ex)</code></pre><p>Get the dual expression of <code>ex</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.struct2namedtuple-Tuple{Any}" href="#NiLangCore.struct2namedtuple-Tuple{Any}"><code>NiLangCore.struct2namedtuple</code></a> — <span class="docstring-category">Method</span></header><section><div><p>convert an object to a named tuple.</p></div></section></article><h2 id="Instructions-1"><a class="docs-heading-anchor" href="#Instructions-1">Instructions</a><a class="docs-heading-anchor-permalink" href="#Instructions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLang.DEC-Tuple{Real}" href="#NiLang.DEC-Tuple{Real}"><code>NiLang.DEC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DEC(a!) -&gt; a! - 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.INC-Tuple{Real}" href="#NiLang.INC-Tuple{Real}"><code>NiLang.INC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">INC(a!) -&gt; a! + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.IROT-Tuple{Real,Real,Real}" href="#NiLang.IROT-Tuple{Real,Real,Real}"><code>NiLang.IROT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">IROT(a!, b!, θ) -&gt; ROT(a!, b!, -θ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.NEG-Tuple{Real}" href="#NiLang.NEG-Tuple{Real}"><code>NiLang.NEG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NEG(a!) -&gt; -a!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.ROT-Tuple{Real,Real,Real}" href="#NiLang.ROT-Tuple{Real,Real,Real}"><code>NiLang.ROT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ROT(a!, b!, θ) -&gt; a!&#39;, b!&#39;, θ</code></pre><div>\[\begin{align}
    {\rm ROT}(a!, b!, \theta)  = \begin{bmatrix}
        \cos(\theta) &amp; - \sin(\theta)\\
        \sin(\theta)  &amp; \cos(\theta)
    \end{bmatrix}
    \begin{bmatrix}
        a!\\
        b!
    \end{bmatrix},
\end{align}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL86-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.SWAP-Union{Tuple{T}, Tuple{T,T}} where T" href="#NiLang.SWAP-Union{Tuple{T}, Tuple{T,T}} where T"><code>NiLang.SWAP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SWAP(a!, b!) -&gt; b!, a!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/instructs.jl#LL78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.arshift-Union{Tuple{T}, Tuple{T,Any}} where T" href="#NiLang.arshift-Union{Tuple{T}, Tuple{T,Any}} where T"><code>NiLang.arshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arshift(x, n)</code></pre><p>right shift, sign extending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/utils.jl#LL27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.mulint-Tuple{Any,Integer}" href="#NiLang.mulint-Tuple{Any,Integer}"><code>NiLang.mulint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulint(a!, b::Integer) -&gt; a!*b, b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.plshift-Tuple{Any,Any}" href="#NiLang.plshift-Tuple{Any,Any}"><code>NiLang.plshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plshift(x, n)</code></pre><p>periodic left shift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/utils.jl#LL13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.prshift-Tuple{Any,Any}" href="#NiLang.prshift-Tuple{Any,Any}"><code>NiLang.prshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plshift(x, n)</code></pre><p>periodic right shift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/utils.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.rot-Tuple{Any,Any,Any}" href="#NiLang.rot-Tuple{Any,Any,Any}"><code>NiLang.rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rot(a, b, θ)</code></pre><p>rotate variables <code>a</code> and <code>b</code> by an angle <code>θ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/utils.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AutoBcast" href="#NiLang.AutoBcast"><code>NiLang.AutoBcast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AutoBcast{T,N} &lt;: IWrapper{T}</code></pre><p>A vectorized variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autobcast.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.NoGrad" href="#NiLang.NoGrad"><code>NiLang.NoGrad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoGrad{T} &lt;: IWrapper{T}
NoGrad(x)</code></pre><p>A <code>NoGrad(x)</code> is equivalent to <code>GVar^{-1}(x)</code>, which cancels the <code>GVar</code> wrapper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L5">source</a></section></article><h2 id="Automatic-Differentiation-1"><a class="docs-heading-anchor" href="#Automatic-Differentiation-1">Automatic Differentiation</a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.@nograd-Tuple{Any}" href="#NiLang.AD.@nograd-Tuple{Any}"><code>NiLang.AD.@nograd</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@nograd f(args...)</code></pre><p>Mark <code>f(args...)</code> as having no gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/vars.jl#LL107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.check_grad-Tuple{Any,Any}" href="#NiLang.AD.check_grad-Tuple{Any,Any}"><code>NiLang.AD.check_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_grad(f, args; atol::Real=1e-8, verbose::Bool=false, iloss::Int, kwargs...)</code></pre><p>Return true if the gradient of <code>f(args..., kwargs...)</code> is reversible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/checks.jl#LL102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.grad-Tuple{NiLang.AD.GVar}" href="#NiLang.AD.grad-Tuple{NiLang.AD.GVar}"><code>NiLang.AD.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad(var)</code></pre><p>Get the gradient field of <code>var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.gradient_numeric-Tuple{Any,Any}" href="#NiLang.AD.gradient_numeric-Tuple{Any,Any}"><code>NiLang.AD.gradient_numeric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient_numeric(f, args...; iloss, kwargs...)</code></pre><p>Numeric differentiating f(args..., kwargs...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/checks.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.hessian_backback-Tuple{Any,Any}" href="#NiLang.AD.hessian_backback-Tuple{Any,Any}"><code>NiLang.AD.hessian_backback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hessian_backback(f, args; iloss::Int, kwargs...)</code></pre><p>Obtain the Hessian matrix of <code>f(args..., kwargs...)</code> by back propagating adjoint program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/hessian_backback.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.jacobian-Tuple{Any,Vararg{Any,N} where N}" href="#NiLang.AD.jacobian-Tuple{Any,Vararg{Any,N} where N}"><code>NiLang.AD.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian(f, args...; iin::Int, iout::Int=iin, kwargs...)</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> using vectorized variables in the gradient field. One can use key word arguments <code>iin</code> and <code>iout</code> to specify the input and output tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/jacobian.jl#LL23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.jacobian_repeat-Tuple{Any,Vararg{Any,N} where N}" href="#NiLang.AD.jacobian_repeat-Tuple{Any,Vararg{Any,N} where N}"><code>NiLang.AD.jacobian_repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian_repeat(f, args...; iin::Int, iout::Int=iin, kwargs...)</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> using repeated computing gradients for each output. One can use key word arguments <code>iin</code> and <code>iout</code> to specify the input and output tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/jacobian.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.GVar" href="#NiLang.AD.GVar"><code>NiLang.AD.GVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GVar{T,GT} &lt;: IWrapper{T}
GVar(x)</code></pre><p>Attach a gradient field to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.NGrad" href="#NiLang.AD.NGrad"><code>NiLang.AD.NGrad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NGrad{N,FT} &lt;: Function</code></pre><p>Obtain gradients <code>Grad(f)(Val(i), args..., kwargs...)</code>, where <code>i</code> is the index of loss in <code>args</code>. <code>Grad</code> object calls forward first, and then backward.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Val(1)</code> is specially optimized, so putting the loss as the first parameter can avoid potential overhead.</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/4cd959420b2729320b4750c466f41a6b7276697f/src/autodiff/gradfunc.jl#LL3-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/sharedwrite/">« The shared write problem on GPU</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 6 June 2020 05:30">Saturday 6 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
