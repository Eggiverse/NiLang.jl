<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Manual · NiLang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NiLang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/besselj/">Bessel function</a></li></ul></li><li><span class="toctext">API Manual</span><ul><li class="current"><a class="toctext" href>API Manual</a><ul class="internal"><li><a class="toctext" href="#Compiling-Tools-(Reexported-from-NiLangCore)-1">Compiling Tools (Reexported from NiLangCore)</a></li><li><a class="toctext" href="#Instructions-1">Instructions</a></li><li><a class="toctext" href="#Automatic-Differentiation-1">Automatic Differentiation</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API Manual</li><li><a href>API Manual</a></li></ul><a class="edit-page" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/api.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Manual-1" href="#API-Manual-1">API Manual</a></h1><h2><a class="nav-anchor" id="Compiling-Tools-(Reexported-from-NiLangCore)-1" href="#Compiling-Tools-(Reexported-from-NiLangCore)-1">Compiling Tools (Reexported from NiLangCore)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@anc-Tuple{Any}" href="#NiLangCore.@anc-Tuple{Any}"><code>NiLangCore.@anc</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@anc x = expr</code></pre><p>Create an ancilla <code>x</code> with initial value <code>expr</code>,</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@assign" href="#NiLangCore.@assign"><code>NiLangCore.@assign</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@assign a b [invcheck]</code></pre><p>Perform the assign <code>a = b</code> in a reversible program. Turn off invertibility check if the <code>invcheck</code> is false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@assignback" href="#NiLangCore.@assignback"><code>NiLangCore.@assignback</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@assignback f(args...) [invcheck]</code></pre><p>Assign input variables with output values: <code>args... = f(args...)</code>, turn off invertibility error check if the second argument is false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@code_interpret-Tuple{Any}" href="#NiLangCore.@code_interpret-Tuple{Any}"><code>NiLangCore.@code_interpret</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@code_interpret ex</code></pre><p>Get the interpreted expression of <code>ex</code>.</p><pre><code class="language-julia-repl">julia&gt; using MacroTools

julia&gt; prettify(@code_interpret x += exp(3.0))
:(@assignback (PlusEq(exp))(x, 3.0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@code_preprocess-Tuple{Any}" href="#NiLangCore.@code_preprocess-Tuple{Any}"><code>NiLangCore.@code_preprocess</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@code_preprocess ex</code></pre><p>Preprocess <code>ex</code> and return the symmetric reversible IR.</p><pre><code class="language-julia-repl">julia&gt; using MacroTools

julia&gt; prettify(@code_preprocess if (x &lt; 3, ~) x += exp(3.0) end)
:(if (x &lt; 3, x &lt; 3)
      x += exp(3.0)
  else
  end)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@code_reverse-Tuple{Any}" href="#NiLangCore.@code_reverse-Tuple{Any}"><code>NiLangCore.@code_reverse</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@code_reverse ex</code></pre><p>Get the reversed expression of <code>ex</code>.</p><pre><code class="language-julia-repl">julia&gt; @code_reverse x += exp(3.0)
:(x -= exp(3.0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@deanc-Tuple{Any}" href="#NiLangCore.@deanc-Tuple{Any}"><code>NiLangCore.@deanc</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@deanc x = expr</code></pre><p>Deallocate ancilla <code>x</code> if <code>x == expr</code>, else throw an <code>InvertibilityError</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@dual-Tuple{Any,Any}" href="#NiLangCore.@dual-Tuple{Any,Any}"><code>NiLangCore.@dual</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@dual f invf</code></pre><p>Define <code>f</code> and <code>invf</code> as a pair of dual instructions, i.e. reverse to each other.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@fieldview-Tuple{Any}" href="#NiLangCore.@fieldview-Tuple{Any}"><code>NiLangCore.@fieldview</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@fieldview fname(x::TYPE) = x.fieldname</code></pre><p>Create a function fieldview that can be accessed by a reversible program</p><pre><code class="language-julia-repl">julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64,Float64}(2.0, 0.0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@i-Tuple{Any}" href="#NiLangCore.@i-Tuple{Any}"><code>NiLangCore.@i</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@i function fname(args..., kwargs...) ... end
@i struct sname ... end</code></pre><p>Define a reversible function/type.</p><pre><code class="language-julia-repl">julia&gt; @i function test(out!, x)
           out! += identity(x)
       end

julia&gt; test(0.2, 0.8)
(1.0, 0.8)

julia&gt; @i struct CVar{T}
           g::T
           x::T
           function CVar{T}(x::T, g::T) where T
               new{T}(x, g)
           end
           function CVar(x::T, g::T) where T
               new{T}(x, g)
           end
           # warning: infered type `T` should be used in `← new` statement only.
           @i function CVar(xx::T) where T
               gg ← zero(xx)
               gg += identity(1)
               xx ← new{T}(gg, xx)
           end
       end

julia&gt; CVar(0.2)
CVar{Float64}(1.0, 0.2)

julia&gt; (~CVar)(CVar(0.2))
0.2</code></pre><p>See <code>test/compiler.jl</code> and <code>test/invtype.jl</code> for more examples.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@icast-Tuple{Any,Any}" href="#NiLangCore.@icast-Tuple{Any,Any}"><code>NiLangCore.@icast</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@icast TDEF1 =&gt; TDEF2 begin ... end</code></pre><p>Define type cast between <code>TDEF1</code> and <code>TDEF2</code>. Type <code>TDEF1</code> or <code>TDEF2</code> can be <code>T(args...)</code> or <code>x::T</code> like.</p><pre><code class="language-julia-repl">julia&gt; struct PVar{T}
           g::T
           x::T
       end

julia&gt; struct SVar{T}
           x::T
           g::T
       end

julia&gt; @icast PVar(g, x) =&gt; SVar(x, k) begin
          g → zero(x)
          k ← zero(x)
          k += identity(x)
       end

julia&gt; x = PVar(0.0, 0.5)
PVar{Float64}(0.0, 0.5)

julia&gt; @instr (PVar=&gt;SVar)(x)
SVar{Float64}(0.5, 0.5)

julia&gt; @instr (SVar=&gt;PVar)(x)
PVar{Float64}(0.0, 0.5)

julia&gt; @icast x::Base.Float64 =&gt; SVar(x, gg) begin
           gg ← zero(x)
           gg += identity(x)
       end

julia&gt; x = 0.5
0.5

julia&gt; @instr (Float64=&gt;SVar)(x)
SVar{Float64}(0.5, 0.5)

julia&gt; @instr (SVar=&gt;Float64)(x)
0.5</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@instr-Tuple{Any}" href="#NiLangCore.@instr-Tuple{Any}"><code>NiLangCore.@instr</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@instr ex</code></pre><p>Execute a reversible instruction.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@invcheck-Tuple{Any}" href="#NiLangCore.@invcheck-Tuple{Any}"><code>NiLangCore.@invcheck</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@invcheck ex
@invcheck x val</code></pre><p>Pass the check it if <code>ex</code> is true or <code>x ≈ val</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@pure_wrapper-Tuple{Any}" href="#NiLangCore.@pure_wrapper-Tuple{Any}"><code>NiLangCore.@pure_wrapper</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@pure_wrapper TYPE</code></pre><p>Create a reversible wrapper type <code>TYPE{T} &lt;: IWrapper{T}</code> that plays a role of simple wrapper.</p><p>```jldoctest; setup=:(using NiLangCore) julia&gt; @pure_wrapper A</p><p>julia&gt; A(0.5) A(0.5)</p><p>julia&gt; (~A)(A(0.5)) 0.5</p><p>julia&gt; -A(0.5) A(-0.5)</p><p>julia&gt; A(0.5) &lt; A(0.6) true</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.@selfdual-Tuple{Any}" href="#NiLangCore.@selfdual-Tuple{Any}"><code>NiLangCore.@selfdual</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@selfdual f</code></pre><p>Define <code>f</code> as a self-dual instructions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.almost_same-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Number" href="#NiLangCore.almost_same-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Number"><code>NiLangCore.almost_same</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">almost_same(a, b; atol=GLOBAL_ATOL[], kwargs...) -&gt; Bool</code></pre><p>Return true if <code>a</code> and <code>b</code> are almost same w.r.t. <code>atol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.check_inv-Tuple{Any,Any}" href="#NiLangCore.check_inv-Tuple{Any,Any}"><code>NiLangCore.check_inv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_inv(f, args; kwargs=(), atol::Real=1e-8, verbose::Bool=false)</code></pre><p>Return true if <code>f(args..., kwargs...)</code> is reversible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.chfield" href="#NiLangCore.chfield"><code>NiLangCore.chfield</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">chfield(x, field, val)</code></pre><p>Change a <code>field</code> of an object <code>x</code>.</p><p>The <code>field</code> can be a <code>Val</code> type</p><pre><code class="language-julia-repl">julia&gt; chfield(1+2im, Val(:im), 5)
1 + 5im</code></pre><p>or a function</p><pre><code class="language-julia-repl">julia&gt; using NiLangCore

julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64,Float64}(2.0, 0.0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.isprimitive-Tuple{Any}" href="#NiLangCore.isprimitive-Tuple{Any}"><code>NiLangCore.isprimitive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isprimitive(f)</code></pre><p>Return <code>true</code> if <code>f</code> is an <code>instruction</code> that can not be decomposed anymore.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.isreflexive-Tuple{Any}" href="#NiLangCore.isreflexive-Tuple{Any}"><code>NiLangCore.isreflexive</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isreflexive(f)</code></pre><p>Return <code>true</code> if a function is self-inverse.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.isreversible-Tuple{Any}" href="#NiLangCore.isreversible-Tuple{Any}"><code>NiLangCore.isreversible</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isreversible(f)</code></pre><p>Return <code>true</code> if a function is reversible.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.nargs" href="#NiLangCore.nargs"><code>NiLangCore.nargs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nargs(instr)</code></pre><p>Number of arguments as the input of <code>instr</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.nouts" href="#NiLangCore.nouts"><code>NiLangCore.nouts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nouts(instr)</code></pre><p>Number of output arguments in the input list of <code>instr</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.tget-Tuple{Tuple,Vararg{Any,N} where N}" href="#NiLangCore.tget-Tuple{Tuple,Vararg{Any,N} where N}"><code>NiLangCore.tget</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tget(x::Tuple, i)</code></pre><p>Get the i-th entry of a tuple.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.unwrap-Tuple{IWrapper}" href="#NiLangCore.unwrap-Tuple{IWrapper}"><code>NiLangCore.unwrap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unwrap(x)</code></pre><p>Unwrap a wrapper instance (recursively) to get the original value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.value-Tuple{Any}" href="#NiLangCore.value-Tuple{Any}"><code>NiLangCore.value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">value(x)</code></pre><p>Get the <code>value</code> from a wrapper instance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.IWrapper" href="#NiLangCore.IWrapper"><code>NiLangCore.IWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IWrapper{T} &lt;: RevType</code></pre><p>IWrapper{T} is a wrapper of for data of type T. It will forward <code>&gt;, &lt;, &gt;=, &lt;=, ≈</code> operations.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.Inv" href="#NiLangCore.Inv"><code>NiLangCore.Inv</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Inv{FT} &lt;: Function
Inv(f)</code></pre><p>The inverse of a function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.InvertibilityError" href="#NiLangCore.InvertibilityError"><code>NiLangCore.InvertibilityError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InvertibilityError &lt;: Exception
InvertibilityError(ex)</code></pre><p>The error thrown when a irreversible statement appears in a reversible context.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.MinusEq" href="#NiLangCore.MinusEq"><code>NiLangCore.MinusEq</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinusEq{FT} &lt;: Function
MinusEq(f)
⊖(f)</code></pre><p>Called when executing <code>out -= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.Partial" href="#NiLangCore.Partial"><code>NiLangCore.Partial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Partial{FIELD, T, T2} &lt;: IWrapper{T2}</p><p>Take a field <code>FIELD</code> without dropping information. This operation can be undone by calling <code>~Partial{FIELD}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.PlusEq" href="#NiLangCore.PlusEq"><code>NiLangCore.PlusEq</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PlusEq{FT} &lt;: Function
PlusEq(f)
⊕(f)</code></pre><p>Called when executing <code>out += f(args...)</code> instruction. The following two statements are same</p><pre><code class="language-julia-repl">julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; x, y, z = PlusEq(*)(x, y, z)
(6.0, 2.0, 3.0)

julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; @instr x += y*z
3.0

julia&gt; x, y, z
(6.0, 2.0, 3.0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.RevType" href="#NiLangCore.RevType"><code>NiLangCore.RevType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RevType</code></pre><p>The base type for reversible types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.XorEq" href="#NiLangCore.XorEq"><code>NiLangCore.XorEq</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">XorEq{FT} &lt;: Function
XorEq(f)
⊙(f)</code></pre><p>Called when executing <code>out ⊻= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.assign_vars-Tuple{Any,Any}" href="#NiLangCore.assign_vars-Tuple{Any,Any}"><code>NiLangCore.assign_vars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">assign_vars(args, symres; invcheck)</code></pre><p>Get the expression of assigning <code>symres</code> to <code>args</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.bcast_assign_vars-Tuple{Any,Any}" href="#NiLangCore.bcast_assign_vars-Tuple{Any,Any}"><code>NiLangCore.bcast_assign_vars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>The broadcast version of <code>assign_vars</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.compile_ex-Tuple{Any,Any}" href="#NiLangCore.compile_ex-Tuple{Any,Any}"><code>NiLangCore.compile_ex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>translate to normal julia code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.dual_ex-Tuple{Any}" href="#NiLangCore.dual_ex-Tuple{Any}"><code>NiLangCore.dual_ex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dual_ex(ex)</code></pre><p>Get the dual expression of <code>ex</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLangCore.struct2namedtuple-Tuple{Any}" href="#NiLangCore.struct2namedtuple-Tuple{Any}"><code>NiLangCore.struct2namedtuple</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>convert an object to a named tuple.</p></div></div></section><h2><a class="nav-anchor" id="Instructions-1" href="#Instructions-1">Instructions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.CONJ-Tuple{Number}" href="#NiLang.CONJ-Tuple{Number}"><code>NiLang.CONJ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CONJ(a!) -&gt; a!&#39;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL43-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.DIVINT-Tuple{Number,Integer}" href="#NiLang.DIVINT-Tuple{Number,Integer}"><code>NiLang.DIVINT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">DIVINT(a!, b::Integer) -&gt; a!/b, b</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL74-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.IROT-Tuple{Number,Number,Number}" href="#NiLang.IROT-Tuple{Number,Number,Number}"><code>NiLang.IROT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IROT(a!, b!, θ) -&gt; ROT(a!, b!, -θ)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL107-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.MULINT-Tuple{Number,Integer}" href="#NiLang.MULINT-Tuple{Number,Integer}"><code>NiLang.MULINT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MULINT(a!, b::Integer) -&gt; a!*b, b</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL67-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.NEG-Tuple{Number}" href="#NiLang.NEG-Tuple{Number}"><code>NiLang.NEG</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">NEG(a!) -&gt; -a!</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL35-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.ROT-Tuple{Number,Number,Number}" href="#NiLang.ROT-Tuple{Number,Number,Number}"><code>NiLang.ROT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ROT(a!, b!, θ) -&gt; a!&#39;, b!&#39;, θ</code></pre><div>\[\begin{align}
    {\rm ROT}(a!, b!, \theta)  = \begin{bmatrix}
        \cos(\theta) &amp; - \sin(\theta)\\
        \sin(\theta)  &amp; \cos(\theta)
    \end{bmatrix}
    \begin{bmatrix}
        a!\\
        b!
    \end{bmatrix},
\end{align}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL86-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.SWAP-Tuple{Number,Number}" href="#NiLang.SWAP-Tuple{Number,Number}"><code>NiLang.SWAP</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SWAP(a!, b!) -&gt; b!, a!</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL59-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.XOR-Tuple{Number,Number}" href="#NiLang.XOR-Tuple{Number,Number}"><code>NiLang.XOR</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">XOR(a!, b) -&gt; a! ⊻ b, b</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/instructs.jl#LL51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.arshift-Union{Tuple{T}, Tuple{T,Any}} where T" href="#NiLang.arshift-Union{Tuple{T}, Tuple{T,Any}} where T"><code>NiLang.arshift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arshift(x, n)</code></pre><p>right shift, sign extending.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/utils.jl#LL28-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.plshift-Tuple{Any,Any}" href="#NiLang.plshift-Tuple{Any,Any}"><code>NiLang.plshift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plshift(x, n)</code></pre><p>periodic left shift.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/utils.jl#LL14-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.prshift-Tuple{Any,Any}" href="#NiLang.prshift-Tuple{Any,Any}"><code>NiLang.prshift</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plshift(x, n)</code></pre><p>periodic right shift.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/utils.jl#LL21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.rot-Tuple{Any,Any,Any}" href="#NiLang.rot-Tuple{Any,Any,Any}"><code>NiLang.rot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rot(a, b, θ)</code></pre><p>rotate variables <code>a</code> and <code>b</code> by an angle <code>θ</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/utils.jl#LL3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AutoBcast" href="#NiLang.AutoBcast"><code>NiLang.AutoBcast</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AutoBcast{T} &lt;: IWrapper{T}</code></pre><p>A vectorized variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L4">source</a></section><h2><a class="nav-anchor" id="Automatic-Differentiation-1" href="#Automatic-Differentiation-1">Automatic Differentiation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.@nograd-Tuple{Any}" href="#NiLang.AD.@nograd-Tuple{Any}"><code>NiLang.AD.@nograd</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@nograd f(args...)</code></pre><p>Mark <code>f(args...)</code> as having no gradients.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/vars.jl#LL97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.beijingring!-Union{Tuple{T}, Tuple{T}} where T" href="#NiLang.AD.beijingring!-Union{Tuple{T}, Tuple{T}} where T"><code>NiLang.AD.beijingring!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">beijingring!(x::AbstractFloat)</code></pre><p>Allocated a new Beijing ring, it will allocate memory on a global tape <code>NiLang.AD.rings</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL40-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.check_grad-Tuple{Any,Any}" href="#NiLang.AD.check_grad-Tuple{Any,Any}"><code>NiLang.AD.check_grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_grad(f, args; kwargs=(), atol::Real=1e-8, verbose::Bool=false)</code></pre><p>Return true if the gradient of <code>f(args..., kwargs...)</code> is reversible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/checks.jl#LL82-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.collect_hessian-Tuple{}" href="#NiLang.AD.collect_hessian-Tuple{}"><code>NiLang.AD.collect_hessian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">collect_hessian()</code></pre><p>Collect hessian data to a matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.grad-Tuple{NiLang.AD.GVar}" href="#NiLang.AD.grad-Tuple{NiLang.AD.GVar}"><code>NiLang.AD.grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">grad(var)</code></pre><p>Get the gradient field of <code>var</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.gradient_numeric-Tuple{Any,Any}" href="#NiLang.AD.gradient_numeric-Tuple{Any,Any}"><code>NiLang.AD.gradient_numeric</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gradient_numeric(f, args; kwargs=())</code></pre><p>Numeric differentiating f(args..., kwargs...).</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/checks.jl#LL62-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.hdata-Union{Tuple{Tuple{NiLang.AD.BeijingRing{T},NiLang.AD.BeijingRing{T}}}, Tuple{T}} where T" href="#NiLang.AD.hdata-Union{Tuple{Tuple{NiLang.AD.BeijingRing{T},NiLang.AD.BeijingRing{T}}}, Tuple{T}} where T"><code>NiLang.AD.hdata</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hdata(h::Tuple{BeijingRing,BeijingRing})</code></pre><p>Get he hessian element of w.r.t. two variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL75-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.hessian_repeat-Tuple{Any,Tuple}" href="#NiLang.AD.hessian_repeat-Tuple{Any,Tuple}"><code>NiLang.AD.hessian_repeat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hessian_repeat(f, args::Tuple; kwargs=())</code></pre><p>Obtain the Hessian matrix of <code>f(args..., kwargs...)</code> by differentiating the first order gradients.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/hessian_repeat.jl#LL39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.jacobian-Tuple{Any,Any}" href="#NiLang.AD.jacobian-Tuple{Any,Any}"><code>NiLang.AD.jacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">jacobian(f, args; kwargs=())</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> by use vectorized variables in the gradient field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/jacobian.jl#LL57-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.jacobian_repeat-Tuple{Any,Any}" href="#NiLang.AD.jacobian_repeat-Tuple{Any,Any}"><code>NiLang.AD.jacobian_repeat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">jacobian_repeat(f, args; kwargs=())</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> by computing one row (gradients) a time.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/jacobian.jl#LL3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.nrings-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#NiLang.AD.nrings-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>NiLang.AD.nrings</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nrings(T)</code></pre><p>Number of rings of type <code>T</code> in global storage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.rings_init!-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#NiLang.AD.rings_init!-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>NiLang.AD.rings_init!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rings_init!(T)</code></pre><p>Remove all rings of type <code>T</code> in global storage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.BeijingRing" href="#NiLang.AD.BeijingRing"><code>NiLang.AD.BeijingRing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BeijingRing{T}</code></pre><p>The type to access global Hessian data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/b3f555cdea82e89e6336bb4c5ab7ed25baec7014/src/autodiff/taylor.jl#LL55-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.GVar" href="#NiLang.AD.GVar"><code>NiLang.AD.GVar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GVar{T,GT} &lt;: IWrapper{T}
GVar(x)</code></pre><p>Attach a gradient field to <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.Loss" href="#NiLang.AD.Loss"><code>NiLang.AD.Loss</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Loss{T} &lt;: IWrapper{T}
Loss(x)</code></pre><p>Wrapper used to mark the loss variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NiLang.AD.NoGrad" href="#NiLang.AD.NoGrad"><code>NiLang.AD.NoGrad</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NoGrad{T} &lt;: IWrapper{T}
NoGrad(x)</code></pre><p>A <code>NoGrad(x)</code> is equivalent to <code>GVar^{-1}(x)</code>, which cancels the <code>GVar</code> wrapper.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L5">source</a></section><footer><hr/><a class="previous" href="../examples/besselj/"><span class="direction">Previous</span><span class="title">Bessel function</span></a></footer></article></body></html>
