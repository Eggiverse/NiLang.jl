var documenterSearchIndex = {"docs":
[{"location":"api/#","page":"API Manual","title":"API Manual","text":"DocTestSetup = quote\n    using NiLangCore, NiLang, NiLang.AD, Test\nend","category":"page"},{"location":"api/#API-Manual-1","page":"API Manual","title":"API Manual","text":"","category":"section"},{"location":"api/#Compiling-Tools-(Reexported-from-NiLangCore)-1","page":"API Manual","title":"Compiling Tools (Reexported from NiLangCore)","text":"","category":"section"},{"location":"api/#","page":"API Manual","title":"API Manual","text":"Modules = [NiLangCore]\nOrder   = [:macro, :function, :type]","category":"page"},{"location":"api/#NiLangCore.@assign","page":"API Manual","title":"NiLangCore.@assign","text":"@assign a b [invcheck]\n\nPerform the assign a = b in a reversible program. Turn off invertibility check if the invcheck is false.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@assignback","page":"API Manual","title":"NiLangCore.@assignback","text":"@assignback f(args...) [invcheck]\n\nAssign input variables with output values: args... = f(args...), turn off invertibility error check if the second argument is false.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@code_julia-Tuple{Any}","page":"API Manual","title":"NiLangCore.@code_julia","text":"@code_julia ex\n\nGet the interpreted expression of ex.\n\njulia> using MacroTools\n\njulia> prettify(@code_julia x += exp(3.0))\n:(@assignback (PlusEq(exp))(x, 3.0))\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@code_preprocess-Tuple{Any}","page":"API Manual","title":"NiLangCore.@code_preprocess","text":"@code_preprocess ex\n\nPreprocess ex and return the symmetric reversible IR.\n\njulia> using MacroTools\n\njulia> prettify(@code_preprocess if (x < 3, ~) x += exp(3.0) end)\n:(if (x < 3, x < 3)\n      x += exp(3.0)\n  else\n  end)\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@code_reverse-Tuple{Any}","page":"API Manual","title":"NiLangCore.@code_reverse","text":"@code_reverse ex\n\nGet the reversed expression of ex.\n\njulia> @code_reverse x += exp(3.0)\n:(x -= exp(3.0))\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@dual-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.@dual","text":"@dual f invf\n\nDefine f and invf as a pair of dual instructions, i.e. reverse to each other.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@fieldview-Tuple{Any}","page":"API Manual","title":"NiLangCore.@fieldview","text":"@fieldview fname(x::TYPE) = x.fieldname\n\nCreate a function fieldview that can be accessed by a reversible program\n\njulia> struct GVar{T, GT}\n           x::T\n           g::GT\n       end\n\njulia> @fieldview xx(x::GVar) = x.x\n\njulia> chfield(GVar(1.0, 0.0), xx, 2.0)\nGVar{Float64,Float64}(2.0, 0.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@i-Tuple{Any}","page":"API Manual","title":"NiLangCore.@i","text":"@i function fname(args..., kwargs...) ... end\n@i struct sname ... end\n\nDefine a reversible function/type.\n\njulia> @i function test(out!, x)\n           out! += identity(x)\n       end\n\njulia> test(0.2, 0.8)\n(1.0, 0.8)\n\njulia> @i struct CVar{T}\n           g::T\n           x::T\n           function CVar{T}(x::T, g::T) where T\n               new{T}(x, g)\n           end\n           function CVar(x::T, g::T) where T\n               new{T}(x, g)\n           end\n           # warning: infered type `T` should be used in `← new` statement only.\n           @i function CVar(xx::T) where T\n               gg ← zero(xx)\n               gg += identity(1)\n               xx ← new{T}(gg, xx)\n           end\n       end\n\njulia> CVar(0.2)\nCVar{Float64}(1.0, 0.2)\n\njulia> (~CVar)(CVar(0.2))\n0.2\n\nSee test/compiler.jl and test/invtype.jl for more examples.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@icast-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.@icast","text":"@icast TDEF1 => TDEF2 begin ... end\n\nDefine type cast between TDEF1 and TDEF2. Type TDEF1 or TDEF2 can be T(args...) or x::T like.\n\njulia> struct PVar{T}\n           g::T\n           x::T\n       end\n\njulia> struct SVar{T}\n           x::T\n           g::T\n       end\n\njulia> @icast PVar(g, x) => SVar(x, k) begin\n          g → zero(x)\n          k ← zero(x)\n          k += identity(x)\n       end\n\njulia> x = PVar(0.0, 0.5)\nPVar{Float64}(0.0, 0.5)\n\njulia> @instr (PVar=>SVar)(x)\nSVar{Float64}(0.5, 0.5)\n\njulia> @instr (SVar=>PVar)(x)\nPVar{Float64}(0.0, 0.5)\n\njulia> @icast x::Base.Float64 => SVar(x, gg) begin\n           gg ← zero(x)\n           gg += identity(x)\n       end\n\njulia> x = 0.5\n0.5\n\njulia> @instr (Float64=>SVar)(x)\nSVar{Float64}(0.5, 0.5)\n\njulia> @instr (SVar=>Float64)(x)\n0.5\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@instr-Tuple{Any}","page":"API Manual","title":"NiLangCore.@instr","text":"@instr ex\n\nExecute a reversible instruction.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@invcheck-Tuple{Any}","page":"API Manual","title":"NiLangCore.@invcheck","text":"@invcheck ex\n@invcheck x val\n\nPass the check it if ex is true or x ≈ val.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@pure_wrapper-Tuple{Any}","page":"API Manual","title":"NiLangCore.@pure_wrapper","text":"@pure_wrapper TYPE\n\nCreate a reversible wrapper type TYPE{T} <: IWrapper{T} that plays a role of simple wrapper.\n\njulia> @pure_wrapper A\n\njulia> A(0.5)\nA(0.5)\n\njulia> (~A)(A(0.5))\n0.5\n\njulia> -A(0.5)\nA(-0.5)\n\njulia> A(0.5) < A(0.6)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@selfdual-Tuple{Any}","page":"API Manual","title":"NiLangCore.@selfdual","text":"@selfdual f\n\nDefine f as a self-dual instructions.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.almost_same-Union{Tuple{T}, Tuple{T,T}} where T<:Number","page":"API Manual","title":"NiLangCore.almost_same","text":"almost_same(a, b; atol=GLOBAL_ATOL[], kwargs...) -> Bool\n\nReturn true if a and b are almost same w.r.t. atol.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.check_inv-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.check_inv","text":"check_inv(f, args; kwargs=(), atol::Real=1e-8, verbose::Bool=false)\n\nReturn true if f(args..., kwargs...) is reversible.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.chfield","page":"API Manual","title":"NiLangCore.chfield","text":"chfield(x, field, val)\n\nChange a field of an object x.\n\nThe field can be a Val type\n\njulia> chfield(1+2im, Val(:im), 5)\n1 + 5im\n\nor a function\n\njulia> using NiLangCore\n\njulia> struct GVar{T, GT}\n           x::T\n           g::GT\n       end\n\njulia> @fieldview xx(x::GVar) = x.x\n\njulia> chfield(GVar(1.0, 0.0), xx, 2.0)\nGVar{Float64,Float64}(2.0, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#NiLangCore.isprimitive-Tuple{Any}","page":"API Manual","title":"NiLangCore.isprimitive","text":"isprimitive(f)\n\nReturn true if f is an instruction that can not be decomposed anymore.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.isreflexive-Tuple{Any}","page":"API Manual","title":"NiLangCore.isreflexive","text":"isreflexive(f)\n\nReturn true if a function is self-inverse.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.isreversible-Tuple{Any}","page":"API Manual","title":"NiLangCore.isreversible","text":"isreversible(f)\n\nReturn true if a function is reversible.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.nargs","page":"API Manual","title":"NiLangCore.nargs","text":"nargs(instr)\n\nNumber of arguments as the input of instr.\n\n\n\n\n\n","category":"function"},{"location":"api/#NiLangCore.nilang_ir-Tuple{Any}","page":"API Manual","title":"NiLangCore.nilang_ir","text":"nilang_ir(ex; reversed::Bool=false)\n\nGet the NiLang reversible IR from the function expression ex, return the reversed function if reversed is true.\n\nThis IR is not directly executable on Julia, please use macroexpand(Main, :(@i function .... end)) to get the julia expression of a reversible function.\n\njulia> ex = :(@inline function f(x!::T, y) where T\n               anc ← zero(T)\n               @routine anc += identity(x!)\n               x! += y * anc\n               ~@routine\n           end);\n\njulia> nilang_ir(ex) |> MacroTools.prettify\n:(@inline function f(x!::T, y) where T\n          anc ← zero(T)\n          anc += identity(x!)\n          x! += y * anc\n          anc -= identity(x!)\n          anc → zero(T)\n      end)\n\njulia> nilang_ir(ex; reversed=true) |> MacroTools.prettify\n:(@inline function (~f)(x!::T, y) where T\n          anc ← zero(T)\n          anc += identity(x!)\n          x! -= y * anc\n          anc -= identity(x!)\n          anc → zero(T)\n      end)\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.nouts","page":"API Manual","title":"NiLangCore.nouts","text":"nouts(instr)\n\nNumber of output arguments in the input list of instr.\n\n\n\n\n\n","category":"function"},{"location":"api/#NiLangCore.tget-Tuple{Tuple,Vararg{Any,N} where N}","page":"API Manual","title":"NiLangCore.tget","text":"tget(x::Tuple, i)\n\nGet the i-th entry of a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.unwrap-Tuple{IWrapper}","page":"API Manual","title":"NiLangCore.unwrap","text":"unwrap(x)\n\nUnwrap a wrapper instance (recursively) to get the original value.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.value-Tuple{Any}","page":"API Manual","title":"NiLangCore.value","text":"value(x)\n\nGet the value from a wrapper instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.IWrapper","page":"API Manual","title":"NiLangCore.IWrapper","text":"IWrapper{T} <: RevType\n\nIWrapper{T} is a wrapper of for data of type T. It will forward >, <, >=, <=, ≈ operations.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.Inv","page":"API Manual","title":"NiLangCore.Inv","text":"Inv{FT} <: Function\nInv(f)\n\nThe inverse of a function.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.InvertibilityError","page":"API Manual","title":"NiLangCore.InvertibilityError","text":"InvertibilityError <: Exception\nInvertibilityError(ex)\n\nThe error thrown when a irreversible statement appears in a reversible context.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.MinusEq","page":"API Manual","title":"NiLangCore.MinusEq","text":"MinusEq{FT} <: Function\nMinusEq(f)\n⊖(f)\n\nCalled when executing out -= f(args...) instruction. See PlusEq for detail.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.Partial","page":"API Manual","title":"NiLangCore.Partial","text":"Partial{FIELD, T, T2} <: IWrapper{T2}\n\nTake a field FIELD without dropping information. This operation can be undone by calling ~Partial{FIELD}.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.PlusEq","page":"API Manual","title":"NiLangCore.PlusEq","text":"PlusEq{FT} <: Function\nPlusEq(f)\n⊕(f)\n\nCalled when executing out += f(args...) instruction. The following two statements are same\n\njulia> x, y, z = 0.0, 2.0, 3.0\n(0.0, 2.0, 3.0)\n\njulia> x, y, z = PlusEq(*)(x, y, z)\n(6.0, 2.0, 3.0)\n\njulia> x, y, z = 0.0, 2.0, 3.0\n(0.0, 2.0, 3.0)\n\njulia> @instr x += y*z\n3.0\n\njulia> x, y, z\n(6.0, 2.0, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.RevType","page":"API Manual","title":"NiLangCore.RevType","text":"RevType\n\nThe base type for reversible types.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.XorEq","page":"API Manual","title":"NiLangCore.XorEq","text":"XorEq{FT} <: Function\nXorEq(f)\n⊙(f)\n\nCalled when executing out ⊻= f(args...) instruction. See PlusEq for detail.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLangCore.@anc-Tuple{Any}","page":"API Manual","title":"NiLangCore.@anc","text":"@anc x = expr\n\nCreate an ancilla x with initial value expr,\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.@deanc-Tuple{Any}","page":"API Manual","title":"NiLangCore.@deanc","text":"@deanc x = expr\n\nDeallocate ancilla x if x == expr, else throw an InvertibilityError.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLangCore.assign_vars-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.assign_vars","text":"assign_vars(args, symres; invcheck)\n\nGet the expression of assigning symres to args.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.bcast_assign_vars-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.bcast_assign_vars","text":"The broadcast version of assign_vars\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.compile_ex-Tuple{Any,Any}","page":"API Manual","title":"NiLangCore.compile_ex","text":"translate to normal julia code.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.dual_ex-Tuple{Any}","page":"API Manual","title":"NiLangCore.dual_ex","text":"dual_ex(ex)\n\nGet the dual expression of ex.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLangCore.struct2namedtuple-Tuple{Any}","page":"API Manual","title":"NiLangCore.struct2namedtuple","text":"convert an object to a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instructions-1","page":"API Manual","title":"Instructions","text":"","category":"section"},{"location":"api/#","page":"API Manual","title":"API Manual","text":"Modules = [NiLang]\nOrder   = [:macro, :function, :type]","category":"page"},{"location":"api/#NiLang.CONJ-Tuple{Number}","page":"API Manual","title":"NiLang.CONJ","text":"CONJ(a!) -> a!'\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.DIVINT-Tuple{Number,Integer}","page":"API Manual","title":"NiLang.DIVINT","text":"DIVINT(a!, b::Integer) -> a!/b, b\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.IROT-Tuple{Number,Number,Number}","page":"API Manual","title":"NiLang.IROT","text":"IROT(a!, b!, θ) -> ROT(a!, b!, -θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.MULINT-Tuple{Number,Integer}","page":"API Manual","title":"NiLang.MULINT","text":"MULINT(a!, b::Integer) -> a!*b, b\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.NEG-Tuple{Number}","page":"API Manual","title":"NiLang.NEG","text":"NEG(a!) -> -a!\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.ROT-Tuple{Number,Number,Number}","page":"API Manual","title":"NiLang.ROT","text":"ROT(a!, b!, θ) -> a!', b!', θ\n\nbeginalign\n    rm ROT(a b theta)  = beginbmatrix\n        cos(theta)  - sin(theta)\n        sin(theta)   cos(theta)\n    endbmatrix\n    beginbmatrix\n        a\n        b\n    endbmatrix\nendalign\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.SWAP-Tuple{Number,Number}","page":"API Manual","title":"NiLang.SWAP","text":"SWAP(a!, b!) -> b!, a!\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.XOR-Tuple{Number,Number}","page":"API Manual","title":"NiLang.XOR","text":"XOR(a!, b) -> a! ⊻ b, b\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.arshift-Union{Tuple{T}, Tuple{T,Any}} where T","page":"API Manual","title":"NiLang.arshift","text":"arshift(x, n)\n\nright shift, sign extending.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.plshift-Tuple{Any,Any}","page":"API Manual","title":"NiLang.plshift","text":"plshift(x, n)\n\nperiodic left shift.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.prshift-Tuple{Any,Any}","page":"API Manual","title":"NiLang.prshift","text":"plshift(x, n)\n\nperiodic right shift.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.rot-Tuple{Any,Any,Any}","page":"API Manual","title":"NiLang.rot","text":"rot(a, b, θ)\n\nrotate variables a and b by an angle θ\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AutoBcast","page":"API Manual","title":"NiLang.AutoBcast","text":"AutoBcast{T} <: IWrapper{T}\n\nA vectorized variable.\n\n\n\n\n\n","category":"type"},{"location":"api/#Automatic-Differentiation-1","page":"API Manual","title":"Automatic Differentiation","text":"","category":"section"},{"location":"api/#","page":"API Manual","title":"API Manual","text":"Modules = [NiLang.AD]\nOrder   = [:macro, :function, :type]","category":"page"},{"location":"api/#NiLang.AD.@nograd-Tuple{Any}","page":"API Manual","title":"NiLang.AD.@nograd","text":"@nograd f(args...)\n\nMark f(args...) as having no gradients.\n\n\n\n\n\n","category":"macro"},{"location":"api/#NiLang.AD.beijingring!-Union{Tuple{T}, Tuple{T}} where T","page":"API Manual","title":"NiLang.AD.beijingring!","text":"beijingring!(x::AbstractFloat)\n\nAllocated a new Beijing ring, it will allocate memory on a global tape NiLang.AD.rings.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.check_grad-Tuple{Any,Any}","page":"API Manual","title":"NiLang.AD.check_grad","text":"check_grad(f, args; kwargs=(), atol::Real=1e-8, verbose::Bool=false)\n\nReturn true if the gradient of f(args..., kwargs...) is reversible.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.collect_hessian-Tuple{}","page":"API Manual","title":"NiLang.AD.collect_hessian","text":"collect_hessian()\n\nCollect hessian data to a matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.grad-Tuple{NiLang.AD.GVar}","page":"API Manual","title":"NiLang.AD.grad","text":"grad(var)\n\nGet the gradient field of var.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.gradient_numeric-Tuple{Any,Any}","page":"API Manual","title":"NiLang.AD.gradient_numeric","text":"gradient_numeric(f, args; kwargs=())\n\nNumeric differentiating f(args..., kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.hdata-Union{Tuple{Tuple{NiLang.AD.BeijingRing{T},NiLang.AD.BeijingRing{T}}}, Tuple{T}} where T","page":"API Manual","title":"NiLang.AD.hdata","text":"hdata(h::Tuple{BeijingRing,BeijingRing})\n\nGet he hessian element of w.r.t. two variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.hessian_repeat-Tuple{Any,Tuple}","page":"API Manual","title":"NiLang.AD.hessian_repeat","text":"hessian_repeat(f, args::Tuple; kwargs=())\n\nObtain the Hessian matrix of f(args..., kwargs...) by differentiating the first order gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.jacobian-Tuple{Any,Any}","page":"API Manual","title":"NiLang.AD.jacobian","text":"jacobian(f, args; kwargs=())\n\nGet the Jacobian matrix for function f(args..., kwargs...) by use vectorized variables in the gradient field.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.jacobian_repeat-Tuple{Any,Any}","page":"API Manual","title":"NiLang.AD.jacobian_repeat","text":"jacobian_repeat(f, args; kwargs=())\n\nGet the Jacobian matrix for function f(args..., kwargs...) by computing one row (gradients) a time.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.nrings-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Manual","title":"NiLang.AD.nrings","text":"nrings(T)\n\nNumber of rings of type T in global storage.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.rings_init!-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API Manual","title":"NiLang.AD.rings_init!","text":"rings_init!(T)\n\nRemove all rings of type T in global storage.\n\n\n\n\n\n","category":"method"},{"location":"api/#NiLang.AD.BeijingRing","page":"API Manual","title":"NiLang.AD.BeijingRing","text":"BeijingRing{T}\n\nThe type to access global Hessian data.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLang.AD.GVar","page":"API Manual","title":"NiLang.AD.GVar","text":"GVar{T,GT} <: IWrapper{T}\nGVar(x)\n\nAttach a gradient field to x.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLang.AD.Loss","page":"API Manual","title":"NiLang.AD.Loss","text":"Loss{T} <: IWrapper{T}\nLoss(x)\n\nWrapper used to mark the loss variable.\n\n\n\n\n\n","category":"type"},{"location":"api/#NiLang.AD.NoGrad","page":"API Manual","title":"NiLang.AD.NoGrad","text":"NoGrad{T} <: IWrapper{T}\nNoGrad(x)\n\nA NoGrad(x) is equivalent to GVar^{-1}(x), which cancels the GVar wrapper.\n\n\n\n\n\n","category":"type"},{"location":"instructions/#Instruction-Reference-1","page":"Instruction Reference","title":"Instruction Reference","text":"","category":"section"},{"location":"instructions/#Instruction-definitions-1","page":"Instruction Reference","title":"Instruction definitions","text":"","category":"section"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"The Julia functions and symbols for instructions","category":"page"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"instruction translated symbol\ny mathrel+= f(args) PlusEq(f)(args...) oplus\ny mathrel-= f(args) MinusEq(f)(args...) ominus\ny mathrelveebar= f(args) \\texttt{XorEq(f)(args...) odot","category":"page"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"The list of reversible instructions that implemented in NiLang","category":"page"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"instruction output\nrm SWAP(a b) b a\nrm ROT(a b theta) a costheta - bsintheta b costheta + asintheta theta\nrm IROT(a b theta) a costheta + bsintheta b costheta - asintheta theta\nrm MULINT(a b) a * b b\nrm DIVINT(a b) a  b b\ny mathrel+= a^wedge b y+a^b a b\ny mathrel+= exp(x) y+e^x x\ny mathrel+= log(x) y+log x x\ny mathrel+= sin(x) y+sin x x\ny mathrel+= cos(x) y+cos x x\ny mathrel+= rm abs(x) $y+\nrm NEG(y) -y\nrm CONJ(y) y","category":"page"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"\".\" is the broadcasting operations in Julia. The second argument of MULINT and DIVINT should be a nonzero integer.","category":"page"},{"location":"instructions/#Notes-1","page":"Instruction Reference","title":"Notes","text":"","category":"section"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"What are MULINT and DIVINT reversible? The range of number representable by integer is much less than a floating point number, multiplying an integer to floating point number does not cause much rounding error, even less than floating point adder. However, multiplying or dividing two floating point numbers should not be considered reversible.","category":"page"},{"location":"instructions/#Jacobians-and-Hessians-for-Instructions-1","page":"Instruction Reference","title":"Jacobians and Hessians for Instructions","text":"","category":"section"},{"location":"instructions/#","page":"Instruction Reference","title":"Instruction Reference","text":"See my blog post.","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"EditURL = \"https://github.com/GiggleLiu/NiLang.jl/blob/master/examples/besselj.jl\"","category":"page"},{"location":"examples/besselj/#Bessel-function-1","page":"Bessel function","title":"Bessel function","text":"","category":"section"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"An Bessel function of the first kind of order nu can be computed using Taylor expansion","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"    J_nu(z) = sumlimits_n=0^infty frac(z2)^nuGamma(k+1)Gamma(k+nu+1) (-z^24)^n","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"where Gamma(n) = (n-1) is the Gamma function. One can compute the accumulated item iteratively as s_n = -fracz^24 s_n-1. Intuitively, this problem mimics the famous pebble game, since one can not release state s_n-1 directly after computing s_n. One would need an increasing size of tape to cache the intermediate state. To circumvent this problem. We introduce the following reversible approximate multiplier","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"using NiLang, NiLang.AD\n\n@i @inline function imul(out!, x, anc!)\n    anc! += out! * x\n    out! -= anc! / x\n    SWAP(out!, anc!)\nend","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"Here, the definition of SWAP can be found in \\App{app:instr}, anc approx 0 is a dirty ancilla. Line 2 computes the result and accumulates it to the dirty ancilla, we get an approximately correct output in anc!. Line 3 \"uncomputes\" out! approximately by using the information stored in anc!, leaving a dirty zero state in register out!. Line 4 swaps the contents in out! and anc!. Finally, we have an approximately correct output and a dirtier ancilla. With this multiplier, we implementation J_nu as follows.","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"@i function ibesselj(out!, ν, z; atol=1e-8)\n    k ← 0\n    fact_nu ← zero(ν)\n    halfz ← zero(z)\n    halfz_power_nu ← zero(z)\n    halfz_power_2 ← zero(z)\n    out_anc ← zero(z)\n    anc1 ← zero(z)\n    anc2 ← zero(z)\n    anc3 ← zero(z)\n    anc4 ← zero(z)\n    anc5 ← zero(z)\n\n    @routine begin\n        halfz += z / 2\n        halfz_power_nu += halfz ^ ν\n        halfz_power_2 += halfz ^ 2\n        ifactorial(fact_nu, ν)\n\n        anc1 += halfz_power_nu/fact_nu\n        out_anc += identity(anc1)\n        while (abs(unwrap(anc1)) > atol && abs(unwrap(anc4)) < atol, k!=0)\n            k += identity(1)\n            @routine begin\n                anc5 += identity(k)\n                anc5 += identity(ν)\n                anc2 -= k * anc5\n                anc3 += halfz_power_2 / anc2\n            end\n            imul(anc1, anc3, anc4)\n            out_anc += identity(anc1)\n            ~@routine\n        end\n    end\n    out! += identity(out_anc)\n    ~@routine\nend","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"where the ifactorial is defined as","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"@i function ifactorial(out!, n)\n    out! += identity(1)\n    for i=1:n\n        MULINT(out!, i)\n    end\nend","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"Here, only a constant number of ancillas are used in this implementation, while the algorithm complexity does not increase comparing to its irreversible counterpart. ancilla anc4 plays the role of dirty ancilla in multiplication, it is uncomputed rigoriously in the uncomputing stage. The reason why the \"approximate uncomputing\" trick works here lies in the fact that from the mathematic perspective the state in nth step s_n z contains the same amount of information as the state in the n-1th step s_n-1 z except some special points, it is highly possible to find an equation to uncompute the previous state from the current state. This trick can be used extensively in many other application. It mitigated the artifitial irreversibility brought by the number system that we have adopt at the cost of precision.","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"To obtain gradients, one can wrap the variable y! with Loss type and feed it into ibesselj'","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"y, x = 0.0, 3.0\nibesselj'(Loss(y), 2, x)","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"Here, ibesselj' is a callable instance of type Grad{typeof(ibesselj)}}. This function itself is reversible and differentiable, one can back-propagate this function to obtain Hessians. In NiLang, it is implemented as hessian_repeat.","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"hessian_repeat(ibesselj, (Loss(y), 2, x))","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"","category":"page"},{"location":"examples/besselj/#","page":"Bessel function","title":"Bessel function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#NiLang.jl-1","page":"Home","title":"NiLang.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"NiLang is a reversible eDSL that can run backwards. The motation is to support source to source AD.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our paper is comming soon.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Welcome for discussion in Julia slack, #autodiff channel.","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"examples/besselj.md\",\n]\nDepth = 1","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"grammar.md\",\n    \"instructions.md\",\n    \"api.md\",\n]\nDepth = 2","category":"page"},{"location":"grammar/#NiLang-Grammar-1","page":"NiLang Grammar","title":"NiLang Grammar","text":"","category":"section"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"To define a reversible function one can use macro @i plus a function definition like bellow","category":"page"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"\"\"\"\ndocstring...\n\"\"\"\n@i function f(args..., kwargs...) where {...}\n    <stmts>\nend","category":"page"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"where the definition of <stmts> are shown in the grammar bellow. The following is a list of terminologies used in the definition of grammar","category":"page"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"<ident>, symbols\n<num>, numbers\n0\n, empty statement\n<JuliaExpr>, native Julia expression\n\n,  zero or one repetitions.","category":"page"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"Here, all JuliaExpr should be pure, otherwise the reversibility is not guaranteed. Dataview is a view of a data, it can be a bijective mapping of an object, an item of an array or a field of an object.","category":"page"},{"location":"grammar/#","page":"NiLang Grammar","title":"NiLang Grammar","text":"Stmts : 0 \n      | Stmt\n      | Stmts Stmt\n      ;\n\nStmt : BlockStmt\n     | IfStmt\n     | WhileStmt\n     | ForStmt\n     | InstrStmt\n     | RevStmt\n     | AncillaStmt\n     | TypecastStmt \n     | @routine Stmt\n     | @safe <JuliaExpr>\n     | CallStmt\n     ;\n\n\nBlockStmt : 'begin' Stmts 'end';\n\nRevCond : '(' <JuliaExpr> ',' <JuliaExpr> ')';\n\nIfStmt : 'if' RevCond Stmts ['else' Stmts] 'end';\n\nWhileStmt : 'while' RevCond Stmts 'end';\n\nRange : <JuliaExpr> ':' <JuliaExpr> [':' <JuliaExpr>];\n\nForStmt : 'for' <ident> '=' Range Stmts 'end';\n\nKwArg : <ident> '=' <JuliaExpr>;\n\nKwArgs : [KwArgs ','] KwArg ;\n\nCallStmt : <JuliaExpr> '(' [DataViews] [';' KwArgs] ')';\n\nConstant : <num> | 'π';\n\nInstrBinOp : '+=' | '-=' | '⊻=';\n\nInstrTrailer : ['.'] '(' [DataViews] ')';\n\nInstrStmt : DataView InstrBinOp <ident> [InstrTrailer];\n\nRevStmt : '~' Stmt;\n\nAncillaStmt : <ident> '←' <JuliaExpr>\n            | <ident> '→' <JuliaExpr>\n            ;\n\nTypecastStmt : '(' <JuliaExpr> '=>' <JuliaExpr> ')' '(' <ident> ')';\n\n@routine : '@routine' <ident> Stmt;\n\n@safe : '@safe' <JuliaExpr>;\n\nDataViews : 0\n          | DataView\n          | DataViews ',' DataView\n          | DataViews ',' DataView '...'\n          ;\n\nDataView : DataView '[' <JuliaExpr> ']'\n         | DataView '.' <ident>\n         | <JuliaExpr> '(' DataView ')'\n         | DataView '\\''\n         | '-' DataView\n         | Constant\n         | <ident>\n         ;","category":"page"}]
}
