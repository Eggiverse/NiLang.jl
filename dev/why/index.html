<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>What and Why · NiLang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NiLang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>What and Why</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#what-is-reversible-computing-1">what is reversible computing</a></li><li><a class="toctext" href="#Why-reversible-computing-is-the-future:-a-physicist&#39;s-perspective-1">Why reversible computing is the future: a physicist&#39;s perspective</a></li><li><a class="toctext" href="#From-the-artificial-intelligence-perspective-1">From the artificial intelligence perspective</a></li><li><a class="toctext" href="#Embrace-Reversible-Computing:-Software-goes-first-1">Embrace Reversible Computing: Software goes first</a></li><li><a class="toctext" href="#FAQ-1">FAQ</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/besselj/">Bessel function</a></li><li><a class="toctext" href="../examples/sparse/">Sparse matrices</a></li><li><a class="toctext" href="../examples/sharedwrite/">The shared write problem on GPU</a></li></ul></li><li><span class="toctext">API &amp; Manual</span><ul><li><a class="toctext" href="../instructions/">Instruction Reference</a></li><li><a class="toctext" href="../extend/">How to extend</a></li><li><a class="toctext" href="../api/">API Manual</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>What and Why</a></li></ul><a class="edit-page" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/why.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>What and Why</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="What-is-Reversible-Computing-and-why-do-we-need-it-1" href="#What-is-Reversible-Computing-and-why-do-we-need-it-1">What is Reversible Computing and why do we need it</a></h1><h1><a class="nav-anchor" id="what-is-reversible-computing-1" href="#what-is-reversible-computing-1">what is reversible computing</a></h1><p>Reversible computing is a computing paradigm that can deterministically undo all the previous changes, which requires user not erasing any information during computations. It boomed during 1970-2005, however, but runs into a winter after that. The following book covers most of reversible computing that you want to know, especially the software part.</p><p><img src="../asset/revcomp.jpg" alt="Introduction to Reversible Computing"/></p><h2><a class="nav-anchor" id="Why-reversible-computing-is-the-future:-a-physicist&#39;s-perspective-1" href="#Why-reversible-computing-is-the-future:-a-physicist&#39;s-perspective-1">Why reversible computing is the future: a physicist&#39;s perspective</a></h2><p>Reversible computing can do anything traditional computing can do. It can be simulated on a irreversible device, but sometimes need either more space or time or both. So, why are people still interested in reversible computing?</p><h3><a class="nav-anchor" id="From-the-energy-perspective-1" href="#From-the-energy-perspective-1">From the energy perspective</a></h3><p>Energy is one of the most important bottleneck of computation. Energy efficiency of computing devices affect the value of <a href="https://www.investopedia.com/news/do-bitcoin-mining-energy-costs-influence-its-price/">bitcoins</a>, user experiences of your cell phone, artificial intelligence (AI) industry.</p><p>Reversible computing devices are more energy efficiency, citing the famous <a href="https://en.wikipedia.org/wiki/Landauer%27s_principle">Landauer&#39;s principle</a></p><blockquote><p>Landauer&#39;s principle is a physical principle pertaining to the lower theoretical limit of energy consumption of computation. It holds that &quot;any logically irreversible manipulation of information, such as the erasure of a bit or the merging of two computation paths, must be accompanied by a corresponding entropy increase in non-information-bearing degrees of freedom of the information-processing apparatus or its environment&quot;.Another way of phrasing Landauer&#39;s principle is that if an observer loses information about a physical system, the observer loses the ability to extract work from that system.</p></blockquote><p>In the future, the building block of information technology is probably based on microscopic dynamics (e.g. cold atoms, DNA, quantum dot). Irreversibility is rare in these systems. Irreversible dynamics is available only in macroscopic world, where you assume the existence an infinite sized &quot;bath&quot;. For example, Like &quot;measure&quot; operation in quantum computing (a kind of reversible computing) is irreversible, as well as one of the slowest operation on quantum devices, one have to wait for the read out signal.</p><p>However, investors lost interest to reversible computing at around 2005 according to <a href="https://arxiv.org/abs/1803.02789">this paper</a> because energy efficiency of traditional CMOS is still approximately 2 orders above the Landauer&#39;s limit, there should still be a lot room to improve, while many reversible computing devices are not &quot;technical smooth&quot;. </p><p>Undoubtedly, traditional CMOS comes into the bottleneck of energy efficiency recent years. The reversible computing scheme adiabatic CMOS is technical smooth and shows orders more energy efficient than traditional CMOS, and it is <a href="https://www.osti.gov/servlets/purl/1377599">already useful in spacecrafts</a>. The detailed analysis of the energy-speed trade off in adiabatic CMOS can be found <a href="https://www3.nd.edu/~lent/pdf/nd/AdiabaticCMOS_HanninenSniderLent2014.pdf">here</a>.</p><h2><a class="nav-anchor" id="From-the-artificial-intelligence-perspective-1" href="#From-the-artificial-intelligence-perspective-1">From the artificial intelligence perspective</a></h2><p>In reversible programming, <a href="https://arxiv.org/abs/2003.04617">differentiable programming is directly achievable</a>. Notice most differentiable programming are built up of basic instructions like &quot;+&quot;, &quot;*&quot;, &quot;/&quot;, &quot;-&quot;. We can use these basic instructions to write Bessel functions, singular value decompositions et. al. Reversible programming allows you to define adjoint rules on instructions only, rather than defining a lot primitives. <strong>This timing is perfect because at this timing, AI is very popular with a lot amazing applications. It requires reversibility for AD, and it is also power consuming.</strong> In the past, most source to source AD frameworks are based checkpointing. Checkpointing is a naive version of reversible programming that caches everything into a global stack. Reversible programming provides us more flexibility.</p><h2><a class="nav-anchor" id="Embrace-Reversible-Computing:-Software-goes-first-1" href="#Embrace-Reversible-Computing:-Software-goes-first-1">Embrace Reversible Computing: Software goes first</a></h2><ol><li>Reversible hardwares relies on reversible software and compiling techniques.</li></ol><p>The inverse is not true. Reversible hardware is an energy efficient host for reversible programs.</p><ol><li>Reversible programming is already useful in machine learning, it is technical smooth to embrace reversible computing from the software side.</li></ol><h2><a class="nav-anchor" id="FAQ-1" href="#FAQ-1">FAQ</a></h2><p><strong>Q: does this compose with cudanative kernels? So we don&#39;t have to write custom adjoints?</strong></p><p>A: It is composible with KernelAbstraction, we have an example <a href="https://giggleliu.github.io/NiLang.jl/dev/examples/besselj/#CUDA-programming-1 ">here</a> For CUDAnative, the problem is the power operations ^ on GPU is not compatible with that on CPU. It can be solved, but needs some patch.</p><p>Still, I want to emphasis writing differentiable parallel kernels have the problem of share read in forward will become shared write when back propagating gradients, which produces wrong gradients. It is a known hard problem in combining CUDA programming and differential programming.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/besselj/"><span class="direction">Next</span><span class="title">Bessel function</span></a></footer></article></body></html>
